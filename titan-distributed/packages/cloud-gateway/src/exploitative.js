/**
 * Titan Cloud Gateway — Exploitative Adjustment Layer (v2)
 *
 * ═══════════════════════════════════════════════════════════════
 * VARIANT-AWARE: PLO5 and PLO6 have completely different
 * threshold curves.  A PLO6 whale at VPIP 70% is a normal PLO5
 * player.  This module uses the `game_variant` field from
 * profile data to select the correct classification thresholds.
 * ═══════════════════════════════════════════════════════════════
 *
 * Takes a GTO-optimal result from the Rust engine and adjusts it
 * based on opponent profiling data. This runs in Node.js (not Rust)
 * because exploitative logic changes frequently and benefits from
 * rapid iteration.
 *
 * Trust Gate:
 *   If profile.trusted === false (hands_played < 50), NO exploit
 *   adjustments are applied — pure GTO.  This prevents catastrophic
 *   misclassification from small samples.
 *
 * Exploitative Taxonomy (Omaha-specific):
 *   1. Overfolder  → bluff more, value-bet thinner
 *   2. Calling Station → stop bluffing, max value-bet
 *   3. Maniac → tighten range, trap more, let them hang themselves
 *   4. Nit → steal relentlessly, fold to their aggression
 *   5. TAG → minimal adjustment, stay GTO
 *   6. LAG → 3-bet tighter for value, increase call frequency
 *   7. Whale → max value, huge sizing, never bluff
 */

"use strict";

const { createLogger } = require("./logger");
const log = createLogger("exploit");

// ── Opponent Archetypes ─────────────────────────────────────────────

const ARCHETYPE = {
  UNKNOWN: "UNKNOWN",
  OVERFOLDER: "OVERFOLDER",
  CALLING_STATION: "CALLING_STATION",
  MANIAC: "MANIAC",
  NIT: "NIT",
  TAG: "TAG",
  LAG: "LAG",
  WHALE: "WHALE",
  REG: "REG",
};

// ── Variant-Specific Thresholds ─────────────────────────────────────
//
// The PONTO CEGO fix:  In PLO6 with 6 cards, VPIP 60-70% is NORMAL
// because players always "connect with something".  Using HE/PLO5
// thresholds (VPIP_LOOSE=45) would misclassify every PLO6 regular
// as a fish.
//

const THRESHOLDS = {
  PLO5: {
    vpip_tight: 30,
    vpip_loose: 55,
    vpip_whale: 70, // Above this = genuine whale
    pfr_passive: 12,
    pfr_agg: 30,
    af_passive: 1.3,
    af_agg: 3.0,
    wtsd_low: 25,
    wtsd_high: 38,
    cbet_low: 30,
    cbet_high: 65,
    fold_to_cbet_high: 60, // Overfolder threshold
  },
  PLO6: {
    vpip_tight: 40, // PLO6 Nit plays < 40% — insanely tight
    vpip_loose: 70, // 70%+ in PLO6 = genuine loose player
    vpip_whale: 85, // Only true whales are 85%+ in PLO6
    pfr_passive: 15,
    pfr_agg: 35,
    af_passive: 1.2,
    af_agg: 2.8,
    wtsd_low: 28,
    wtsd_high: 42,
    cbet_low: 25,
    cbet_high: 55,
    fold_to_cbet_high: 55,
  },
};

// ── Classify Opponent ───────────────────────────────────────────────

/**
 * Classify an opponent using VARIANT-SPECIFIC thresholds.
 *
 * The profile object is expected to come from OpponentDb.getProfile()
 * or PgStore.getProfile(), which already includes:
 *   - trusted: boolean (hands_played >= 50)
 *   - game_variant: string ('PLO5' | 'PLO6')
 *   - vpip, pfr, af, wtsd, fold_to_cbet: computed percentages
 *
 * @param {Object} profile
 * @returns {string} ARCHETYPE value
 */
function classifyOpponent(profile) {
  // Trust Gate: if not enough data, stay GTO
  if (!profile || !profile.trusted) return ARCHETYPE.UNKNOWN;

  const t = THRESHOLDS[profile.game_variant] || THRESHOLDS.PLO5;
  const { vpip, pfr, af, wtsd, fold_to_cbet } = profile;

  // Whale: absurdly loose + passive
  if (vpip > t.vpip_whale) return ARCHETYPE.WHALE;

  // Nit: super tight
  if (vpip < t.vpip_tight && pfr < t.pfr_passive) return ARCHETYPE.NIT;

  // TAG: tight-ish + aggressive
  if (vpip <= t.vpip_loose && pfr >= t.pfr_agg && af >= t.af_agg) {
    return ARCHETYPE.TAG;
  }

  // LAG: loose + aggressive + raises frequently
  if (vpip > t.vpip_loose && af >= t.af_agg && pfr >= t.pfr_agg) {
    return ARCHETYPE.LAG;
  }

  // Maniac: loose + hyper-aggressive
  if (vpip >= t.vpip_loose && af >= t.af_agg) return ARCHETYPE.MANIAC;

  // Calling Station: loose + passive
  if (vpip >= t.vpip_loose && af < t.af_passive) {
    return ARCHETYPE.CALLING_STATION;
  }

  // Overfolder: folds too much to c-bets / 3-bets
  if (fold_to_cbet > t.fold_to_cbet_high && wtsd < t.wtsd_low) {
    return ARCHETYPE.OVERFOLDER;
  }

  // Fish: loose + somewhat passive (but not station-level)
  if (vpip > t.vpip_loose && af < t.af_agg) return ARCHETYPE.CALLING_STATION;

  // Reg: balanced, competent — minimal exploit
  if (
    vpip >= t.vpip_tight &&
    vpip <= t.vpip_loose &&
    af >= t.af_passive &&
    af <= t.af_agg
  ) {
    return ARCHETYPE.REG;
  }

  return ARCHETYPE.TAG; // unknown edge case → default to GTO
}

// ── Adjustment Strategies ───────────────────────────────────────────

const ADJUSTMENTS = {
  [ARCHETYPE.UNKNOWN]: {
    desc: "Unknown / untrusted — stay GTO (trust gate active)",
    mod: (gto) => gto,
  },

  [ARCHETYPE.TAG]: {
    desc: "TAG — minimal deviation",
    mod: (gto) => gto,
  },

  [ARCHETYPE.REG]: {
    desc: "Reg — stay close to GTO, slight aggression",
    mod: (gto) => gto,
  },

  [ARCHETYPE.OVERFOLDER]: {
    desc: "Overfolder — increase bluff frequency",
    mod: (gto, profile, ctx) => {
      const f = { ...gto.frequencies };
      const streetMultiplier = ctx.street === "STREET_RIVER" ? 1.4 : 1.2;
      f.raise = Math.min(1.0, f.raise * streetMultiplier);
      f.fold = Math.max(0.0, f.fold * 0.7);
      normalize(f);

      return {
        ...gto,
        frequencies: f,
        action: pickAction(f),
        aggressionModifier: 1.3,
        reasoning: `Overfolder fold_to_cbet=${profile.fold_to_cbet}% [${profile.game_variant}] → bluff more`,
      };
    },
  },

  [ARCHETYPE.CALLING_STATION]: {
    desc: "Calling Station — max value, zero bluffs",
    mod: (gto, profile) => {
      const f = { ...gto.frequencies };
      if (gto.equity < 0.55) {
        f.raise = 0;
        f.allin = 0;
        f.check = Math.max(f.check, 0.6);
      } else {
        f.raise = Math.min(1.0, f.raise * 1.3);
      }
      normalize(f);

      return {
        ...gto,
        frequencies: f,
        action: pickAction(f),
        raiseAmountBb100: Math.round((gto.raiseAmountBb100 || 0) * 1.25),
        aggressionModifier: gto.equity > 0.55 ? 1.4 : 0.4,
        reasoning: `Station VPIP=${profile.vpip}% WTSD=${profile.wtsd}% [${profile.game_variant}] → ${gto.equity > 0.55 ? "overbet value" : "no bluffs"}`,
      };
    },
  },

  [ARCHETYPE.WHALE]: {
    desc: "Whale — max value, massive sizing, never bluff",
    mod: (gto, profile) => {
      const f = { ...gto.frequencies };
      if (gto.equity < 0.5) {
        // Below 50% equity vs whale → check/fold, never bluff
        f.raise = 0;
        f.allin = 0;
        f.bet = 0;
        f.check = Math.max(f.check, 0.7);
      } else {
        // Value-bet relentlessly with massive sizing
        f.raise = Math.min(1.0, f.raise * 1.5);
        f.allin = Math.min(1.0, (f.allin || 0) * 1.3);
      }
      normalize(f);

      return {
        ...gto,
        frequencies: f,
        action: pickAction(f),
        raiseAmountBb100: Math.round((gto.raiseAmountBb100 || 0) * 1.5),
        aggressionModifier: gto.equity > 0.5 ? 1.6 : 0.3,
        reasoning: `Whale VPIP=${profile.vpip}% [${profile.game_variant}] → ${gto.equity > 0.5 ? "massive value" : "no bluffs, pure SD value"}`,
      };
    },
  },

  [ARCHETYPE.MANIAC]: {
    desc: "Maniac — tighten, trap, let them blast off",
    mod: (gto, profile) => {
      const f = { ...gto.frequencies };
      if (gto.equity > 0.45) {
        f.call = Math.min(1.0, f.call * 1.5);
        f.raise = f.raise * 0.6;
        f.fold = f.fold * 0.7;
      }
      normalize(f);

      return {
        ...gto,
        frequencies: f,
        action: pickAction(f),
        aggressionModifier: 0.6,
        reasoning: `Maniac AF=${profile.af} VPIP=${profile.vpip}% [${profile.game_variant}] → trapping`,
      };
    },
  },

  [ARCHETYPE.NIT]: {
    desc: "Nit — steal blinds, fold to their raises",
    mod: (gto, profile, ctx) => {
      const f = { ...gto.frequencies };
      if (ctx.street === "STREET_PREFLOP") {
        f.raise = Math.min(1.0, f.raise * 1.5);
        f.fold = f.fold * 0.5;
      } else {
        f.fold = Math.min(1.0, f.fold * 1.3);
        f.call = f.call * 0.7;
      }
      normalize(f);

      return {
        ...gto,
        frequencies: f,
        action: pickAction(f),
        aggressionModifier: ctx.street === "STREET_PREFLOP" ? 1.5 : 0.5,
        reasoning: `Nit VPIP=${profile.vpip}% PFR=${profile.pfr}% [${profile.game_variant}] → ${ctx.street === "STREET_PREFLOP" ? "steal" : "respect"}`,
      };
    },
  },

  [ARCHETYPE.LAG]: {
    desc: "LAG — 3-bet tighter for value",
    mod: (gto, profile) => {
      const f = { ...gto.frequencies };
      if (gto.equity < 0.6) {
        f.raise = f.raise * 0.7;
        f.call = Math.min(1.0, f.call * 1.3);
      }
      normalize(f);

      return {
        ...gto,
        frequencies: f,
        action: pickAction(f),
        aggressionModifier: 0.8,
        reasoning: `LAG VPIP=${profile.vpip}% AF=${profile.af} [${profile.game_variant}] → tighter 3-bet`,
      };
    },
  },
};

// ── Utility Functions ───────────────────────────────────────────────

function normalize(f) {
  const sum =
    (f.fold || 0) +
    (f.check || 0) +
    (f.call || 0) +
    (f.raise || 0) +
    (f.allin || 0);
  if (sum <= 0) return;
  f.fold = (f.fold || 0) / sum;
  f.check = (f.check || 0) / sum;
  f.call = (f.call || 0) / sum;
  f.raise = (f.raise || 0) / sum;
  f.allin = (f.allin || 0) / sum;
}

function pickAction(f) {
  const entries = [
    ["ACTION_FOLD", f.fold || 0],
    ["ACTION_CHECK", f.check || 0],
    ["ACTION_CALL", f.call || 0],
    ["ACTION_RAISE", f.raise || 0],
    ["ACTION_ALLIN", f.allin || 0],
  ];
  const roll = Math.random();
  let cumulative = 0;
  for (const [action, freq] of entries) {
    cumulative += freq;
    if (roll <= cumulative) return action;
  }
  return entries[entries.length - 1][0];
}

// ── Exploitative Layer Class ────────────────────────────────────────

class ExploitativeLayer {
  /**
   * Adjust a GTO result based on opponent profiles.
   *
   * The profiles MUST include the `trusted` flag from
   * OpponentDb.getProfile() / PgStore.getProfile().
   * If untrusted → pure GTO, no exploit.
   *
   * @param {object} gtoResult - Raw result from SolverBridge
   * @param {object[]} opponentProfiles - Array of profile objects (with trusted flag)
   * @param {object} ctx - Context { street, position, game_variant }
   *
   * @returns {object} Adjusted result with exploit data
   */
  adjust(gtoResult, opponentProfiles, ctx) {
    if (!opponentProfiles || opponentProfiles.length === 0) {
      return {
        ...gtoResult,
        exploitApplied: false,
        aggressionModifier: 1.0,
        reasoning: "No opponent data — pure GTO",
        archetype: ARCHETYPE.UNKNOWN,
      };
    }

    // Multi-way: use the most relevant opponent (last aggressor or IP)
    const primary = opponentProfiles[0];

    // ═══ TRUST GATE ═══
    // If the profile is NOT trusted (< 50 hands), no exploit.
    if (!primary.trusted) {
      log.debug(
        {
          opponent: primary.player_id,
          hands: primary.hands_played,
          variant: primary.game_variant,
        },
        "Trust gate active — insufficient sample, staying GTO",
      );

      return {
        ...gtoResult,
        exploitApplied: false,
        aggressionModifier: 1.0,
        reasoning: `Trust gate: only ${primary.hands_played} hands in ${primary.game_variant} (need 50) — pure GTO`,
        archetype: ARCHETYPE.UNKNOWN,
      };
    }

    const archetype = classifyOpponent(primary);

    const adjuster = ADJUSTMENTS[archetype];
    if (
      !adjuster ||
      archetype === ARCHETYPE.TAG ||
      archetype === ARCHETYPE.REG ||
      archetype === ARCHETYPE.UNKNOWN
    ) {
      return {
        ...gtoResult,
        exploitApplied: false,
        aggressionModifier: 1.0,
        reasoning: adjuster?.desc || "Stay GTO",
        archetype,
      };
    }

    log.debug(
      {
        archetype,
        opponent: primary.player_id,
        variant: primary.game_variant,
        hands: primary.hands_played,
      },
      "Applying exploit adjustment",
    );

    const adjusted = adjuster.mod(gtoResult, primary, ctx);
    return {
      ...adjusted,
      exploitApplied: true,
      archetype,
    };
  }
}

module.exports = {
  ExploitativeLayer,
  classifyOpponent,
  ARCHETYPE,
  THRESHOLDS,
};
